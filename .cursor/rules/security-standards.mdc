---
description: Security standards and best practices for StillOnTime
---

# Security Standards & Best Practices

## ðŸ”’ Security Requirements (MANDATORY)

### Authentication
- **OAuth 2.0 PKCE**: All external integrations (Google APIs, Twilio)
- **JWT Tokens**: API authentication with proper expiration
- **No hardcoded secrets**: Environment variables only
- **Input validation**: All user inputs validated and sanitized
- **Rate limiting**: Implemented on all public endpoints
- **CSRF Protection**: Enabled for state-changing operations
- **HTTPS Only**: Production must enforce secure connections

## ðŸ›¡ï¸ Security Patterns

### OAuth 2.0 PKCE Implementation
```typescript
// Google OAuth with PKCE
import { google } from 'googleapis';
import crypto from 'crypto';

const oauth2Client = new google.auth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  'http://localhost:3000/auth/callback'
);

// PKCE flow
const codeVerifier = crypto.randomBytes(32).toString('base64url');
const codeChallenge = crypto
  .createHash('sha256')
  .update(codeVerifier)
  .digest('base64url');

const authUrl = oauth2Client.generateAuthUrl({
  access_type: 'offline',
  scope: [
    'https://www.googleapis.com/auth/gmail.readonly',
    'https://www.googleapis.com/auth/calendar'
  ],
  code_challenge: codeChallenge,
  code_challenge_method: 'S256'
});
```

### JWT Authentication
```typescript
// JWT token configuration
import jwt from 'jsonwebtoken';

const jwtConfig = {
  secret: process.env.JWT_SECRET,
  expiresIn: '24h',
  issuer: 'stillontime',
  audience: 'stillontime-users'
};

// Token generation
const generateToken = (user: User): string => {
  return jwt.sign(
    { 
      userId: user.id, 
      email: user.email,
      permissions: user.permissions 
    },
    jwtConfig.secret,
    {
      expiresIn: jwtConfig.expiresIn,
      issuer: jwtConfig.issuer,
      audience: jwtConfig.audience
    }
  );
};

// Token validation
const validateToken = (token: string): User => {
  try {
    return jwt.verify(token, jwtConfig.secret, {
      issuer: jwtConfig.issuer,
      audience: jwtConfig.audience
    }) as User;
  } catch (error) {
    throw new AuthenticationError('Invalid token', error);
  }
};
```

### Input Validation
```typescript
// Express validator for input validation
import { body, validationResult } from 'express-validator';

const validateEmailProcessing = [
  body('emailId')
    .isUUID()
    .withMessage('Email ID must be a valid UUID'),
  body('processingType')
    .isIn(['schedule_extraction', 'route_planning', 'calendar_sync'])
    .withMessage('Invalid processing type'),
  body('priority')
    .optional()
    .isInt({ min: 1, max: 5 })
    .withMessage('Priority must be between 1 and 5')
];

const handleValidationErrors = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    throw new ValidationError('Invalid input data', errors.array());
  }
  next();
};
```

### Rate Limiting
```typescript
// Rate limiting middleware
import rateLimit from 'express-rate-limit';

// Global rate limiting
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

// Auth endpoint rate limiting
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 requests per windowMs
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true,
});

// Apply rate limiting
app.use('/api', globalLimiter);
app.use('/api/auth', authLimiter);
```

## ðŸ” Data Protection

### Environment Variables Security
```typescript
// Secure environment variable handling
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_SECRET',
  'OPENAI_API_KEY',
  'GOOGLE_CLIENT_ID',
  'GOOGLE_CLIENT_SECRET',
  'TWILIO_ACCOUNT_SID',
  'TWILIO_AUTH_TOKEN'
];

const validateEnvironment = () => {
  const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
};

// Validate on startup
validateEnvironment();
```

### Data Sanitization
```typescript
// Data sanitization utilities
import DOMPurify from 'isomorphic-dompurify';
import validator from 'validator';

const sanitizeInput = (input: string): string => {
  // Remove HTML tags and sanitize
  const sanitized = DOMPurify.sanitize(input);
  
  // Validate and escape
  return validator.escape(sanitized);
};

const sanitizeEmail = (email: string): string => {
  if (!validator.isEmail(email)) {
    throw new ValidationError('Invalid email format');
  }
  return validator.normalizeEmail(email);
};
```

### Password Security
```typescript
// Password hashing
import bcrypt from 'bcrypt';

const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return await bcrypt.compare(password, hash);
};

// Password strength validation
const validatePasswordStrength = (password: string): boolean => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  return password.length >= minLength && 
         hasUpperCase && 
         hasLowerCase && 
         hasNumbers && 
         hasSpecialChar;
};
```

## ðŸ›¡ï¸ API Security

### CORS Configuration
```typescript
// CORS security configuration
import cors from 'cors';

const corsOptions = {
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://stillontime.com', 'https://www.stillontime.com']
    : ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

app.use(cors(corsOptions));
```

### CSRF Protection
```typescript
// CSRF protection
import csrf from 'csurf';

const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// Apply CSRF protection to state-changing routes
app.use('/api', csrfProtection);
```

### Request Validation
```typescript
// Request size limiting
import express from 'express';

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ limit: '10mb', extended: true }));

// Request timeout
app.use((req, res, next) => {
  req.setTimeout(30000); // 30 seconds
  res.setTimeout(30000);
  next();
});
```

## ðŸ”’ Database Security

### SQL Injection Prevention
```typescript
// Kysely query builder (prevents SQL injection)
const getUserById = async (id: string): Promise<User | null> => {
  return await db
    .selectFrom('users')
    .selectAll()
    .where('id', '=', id) // Parameterized query
    .executeTakeFirst();
};

// Never use string concatenation
// âŒ WRONG
// const query = `SELECT * FROM users WHERE id = '${id}'`;

// âœ… CORRECT
const query = db.selectFrom('users').where('id', '=', id);
```

### Database Connection Security
```typescript
// Secure database connection
const dbConfig = {
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  // Additional security options
  application_name: 'stillontime-backend',
  statement_timeout: 30000
};
```

## ðŸš¨ Security Monitoring

### Security Logging
```typescript
// Security event logging
const securityLogger = {
  logAuthAttempt: (email: string, success: boolean, ip: string) => {
    logger.warn('Authentication attempt', {
      email: email.replace(/(.{2}).*(@.*)/, '$1***$2'), // Mask email
      success,
      ip,
      timestamp: new Date().toISOString(),
      type: 'auth_attempt'
    });
  },
  
  logSecurityViolation: (violation: string, details: any) => {
    logger.error('Security violation', {
      violation,
      details,
      timestamp: new Date().toISOString(),
      type: 'security_violation'
    });
  }
};
```

### Intrusion Detection
```typescript
// Basic intrusion detection
const detectSuspiciousActivity = (req: Request) => {
  const ip = req.ip;
  const userAgent = req.get('User-Agent');
  
  // Check for suspicious patterns
  if (userAgent?.includes('sqlmap') || userAgent?.includes('nikto')) {
    securityLogger.logSecurityViolation('suspicious_user_agent', { ip, userAgent });
    return true;
  }
  
  // Check for rapid requests
  if (req.rateLimit?.remaining === 0) {
    securityLogger.logSecurityViolation('rate_limit_exceeded', { ip });
    return true;
  }
  
  return false;
};
```

## ðŸ” Data Encryption

### Sensitive Data Encryption
```typescript
// Data encryption utilities
import crypto from 'crypto';

const algorithm = 'aes-256-gcm';
const secretKey = crypto.scryptSync(process.env.ENCRYPTION_KEY!, 'salt', 32);

const encryptSensitiveData = (text: string): string => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(algorithm, secretKey);
  cipher.setAAD(Buffer.from('stillontime', 'utf8'));
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
};

const decryptSensitiveData = (encryptedData: string): string => {
  const [ivHex, authTagHex, encrypted] = encryptedData.split(':');
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  
  const decipher = crypto.createDecipher(algorithm, secretKey);
  decipher.setAAD(Buffer.from('stillontime', 'utf8'));
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};
```

## ðŸ›¡ï¸ Security Headers

### Security Headers Middleware
```typescript
// Security headers
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.stillontime.com"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  xssFilter: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
```

## ðŸ” Security Testing

### Security Test Suite
```typescript
// Security tests
describe('Security', () => {
  it('should reject invalid JWT tokens', async () => {
    await request(app)
      .get('/api/user/profile')
      .set('Authorization', 'Bearer invalid-token')
      .expect(401);
  });

  it('should validate input data', async () => {
    await request(app)
      .post('/api/email/process')
      .send({ emailId: '<script>alert("xss")</script>' })
      .expect(400);
  });

  it('should enforce rate limiting', async () => {
    const promises = Array(15).fill(null).map(() => 
      request(app).get('/api/health')
    );
    
    const responses = await Promise.all(promises);
    const rateLimited = responses.some(r => r.status === 429);
    expect(rateLimited).toBe(true);
  });
});
```

## ðŸ“‹ Security Checklist

### Pre-deployment Security Checklist
- [ ] All secrets in environment variables
- [ ] OAuth 2.0 PKCE implemented
- [ ] JWT tokens properly configured
- [ ] Input validation on all endpoints
- [ ] Rate limiting implemented
- [ ] CORS properly configured
- [ ] CSRF protection enabled
- [ ] Security headers set
- [ ] HTTPS enforced
- [ ] Database connections secured
- [ ] SQL injection prevention
- [ ] XSS protection enabled
- [ ] Security logging implemented
- [ ] Error messages don't leak information
- [ ] Authentication properly implemented
- [ ] Authorization checks in place